---
date: "2022-02-21"
title: "블로그를 최적화 해보자..! - Blog Optimization"
creater: "blan19"
categories: ["Web", "Optimization", "React"]
summary: "블로그를 배포하면서 그냥 지나쳤었던 웹 성능 개선을 위해 Optimization 작업을 시작하였다"
thumbnail: "Optimization.png"
---

## 사설

그 동안 미뤄뒀었던 개인 블로그를 만들어 배포하게 되었다..!

다른 거 하기 바쁘다는 핑계로 미뤄두기만 하다가 더이상은 안될 거 같아 급하게 만들어 아직은 많이 부족하다

천천히 개선해가면서 추가해 나가야 할 것도 추가해 나갈 예정!

> 블로그를 배포하면서 평소 써봐야지 하는 스택을 몇개 써봤는데 그 예로 Gatsby이다 내부적으로 GraphQL을 지원하고 소규모 서비스인 블로그를 배포하기에 아주 적합한 거 같아 선택하였다. 그리고 배포는 Vercel과 커스텀 도메인을 위해 Google Domain을 사용하였고,이후 Home Page에 인기 게시글과 트렌딩 게시글을 추적을 위해 Google Analytics를 사용하였다

_이후 블로그를 배포하면서 그냥 지나쳤었던 웹 성능 개선을 위해 Optimization 작업을 시작하였다_

## 블로그 최적화 Start..!

### Properly size images

1. Gatsby Image

블로그 포스트의 썸네일 이미지와 같은 이미지 최적화 작업을 위해 Gatsby에서 지원하는 플러그인인 Gatsby Image plugin 을 사용해
이미지를 최적화하였다

```
npm i gatsby-plugin-image gatsby-plugin-sharp gatsby-transformer-sharp
```

```
module.exports = {
  plugins: [
    ...,
    `gatsby-plugin-sharp`,
    `gatsby-transformer-sharp`,
    `gatsby-plugin-image`,
    ...
  ],
}
```

Gatsby Image plugin의 디폴트 Formats은 ["auto", "webp"]이다. 필요한 포맷팅이 있다면 추가해주자

이 플러그인으로 개츠비에서 내부적으로 가공한 이미지를 받아서 이미지 사이즈와 해상도 조절을 각 컴포넌트에 맞게 받아 이미지 용량을 줄일 수 있다

`src/pages/posts.tsx`

```
export const getPostData = graphql`
  query getPostData {
    allMarkdownRemark(
      sort: { order: DESC, fields: [frontmatter___date, frontmatter___title] }
      filter: { fileAbsolutePath: { regex: "/(/posts/)/" } }
    ) {
      edges {
        node {
          frontmatter {
            thumbnail {
              childImageSharp {
                gatsbyImageData(width: 768, height: 400)
              }
            }
          }
        }
      }
    }
  }
`
```

내가 포스트 썸네일에 필요한 사이즈에 맞춰 Graphql 쿼리를 날리면 내부적으로 개츠비 플러그인이 가공한 이미지를 받게되어 이미지 최적화를 쉽게 할 수 있다

### Reduce unused JavaScript

1. Code Spliting

Gatsby는 정적 사이트 생성을 위한 프레임워크이지만, lazy loading을 적절하게 사용할 수 있는데, lazy loading을 사용하여
화면을 렌더할 때 다른 렌더가 되지 않는 컴포넌트들을 lazy loading을 해 줄 것이다

React 내부적으로 lazy loading을 위해 React.lazy를 지원하지만 나는 @loadable을 사용할 예정이다

```
npm i @loadable/component
```

```
npm i @types/loadable__component -D
```

Page 단에서는 lazy loading과 포스트 리스트와, 데일리 포스트 리스트에서는 preloading을 사용하여 코드 스플리팅을 사용하였다

```
import React from "react";
const PostsList = loadable(() => import("components/Posts/PostsList"));
const HeaderBackgroundImage = loadable(
  () => import("layouts/Header/HeaderBackgroundImage"),
);

    ...

const posts: FunctionComponent<PostsPageProps> = ({
  data: {
    site: {
      siteMetadata: { title, description, siteUrl },
    },
    allMarkdownRemark: { edges },
    cloud: {
      childImageSharp: { gatsbyImageData },
    },
  },
}) => {

    ...

  return (
    <Layouts
      title={title}
      description={description}
      url={siteUrl}
      image={edges[0]?.node.frontmatter.thumbnail.publicURL}
    >
      <HeaderBackgroundImage image={gatsbyImageData} />
      <PostsContainer>
        <PostsCategoryList
          selectedCategory={selectedCategory}
          categoryList={categoryList}
        />
        <PostsList selectedCategory={selectedCategory} posts={edges} />
      </PostsContainer>
    </Layouts>
  )
}

export default posts
```

2. Code Preloading

포스트 리스트에선 마우스를 오버할 때 미리 preloading을 할 수 있도록 preloading을 사용하였다

<img src="https://user-images.githubusercontent.com/66871265/154894025-b79d9b07-1f06-43c0-84ae-a83642a7fa39.png" width="100%" alt="PostList"></img>

```
import React, { FunctionComponent } from "react"
const PostsItem = loadable(() => import("./PostsItem"))

return (
  <PostsListContainer
          onMouseOver={() => PostsItem.preload()}
          ref={containerRef}
        >
          {postList.map(
            ({
              node: {
                id,
                fields: { slug },
                frontmatter,
              },
            }: PostListItemType) => (
        <PostsItem {...frontmatter} link={slug} key={id} />
      ),
    )}
  </PostsListContainer>
);
```

@loadable을 사용하여 간단하게 코드 스플리팅이 가능하다
더 많은 코드 스플리팅 자료는 [Doc](https://loadable-components.com/docs/getting-started/)

### labels ensure that form controls are announced properly by assistive technologies, like screen readers

input 같은 폼 형식에선 label을 붙여줘야 한다!
몰랐던 점이라 이제부터 label을 사용할 예정

```
<label>
<Switch
checked={theme.isDark}
onChange={() => theme.toggleDark()}
width={50}
height={25}
handleDiameter={18}
offColor="#D2D2D2"
onColor="#F1C945"
aria-label="dark-mode"
uncheckedIcon={
<HeaderToggleIconContainer>
<MdLightMode />
</HeaderToggleIconContainer>
}
checkedIcon={
<HeaderToggleIconContainer>
<MdDarkMode />
</HeaderToggleIconContainer>
}
/>
</label>
```

### Links do not have a discernible name

a 태그에는 aria-label을 붙여줘 명확하게 파악이 가능하도록 하자

```
<a href="https://www.instagram.com/jsbb19/" target="_blank" aria-label="my instagram">
```

<img width="100%" alt="Optimization" src="https://user-images.githubusercontent.com/66871265/154895109-f2192d27-c511-4e7a-bbe6-25ea68c2cd00.png">
